{"meta":{"title":"ZDD's Blog","subtitle":"走一步，再走一步","description":"Always Fighting!","author":"Zhang Doudou","url":"https://zhangdoudou.github.io","root":"/"},"pages":[{"title":"tags","date":"2023-03-03T15:34:56.000Z","updated":"2023-03-03T16:01:24.880Z","comments":true,"path":"tags/index.html","permalink":"https://zhangdoudou.github.io/tags/index.html","excerpt":"","text":""},{"title":"简介","date":"2023-03-05T10:21:36.000Z","updated":"2023-03-05T10:52:34.768Z","comments":true,"path":"about/index.html","permalink":"https://zhangdoudou.github.io/about/index.html","excerpt":"","text":"1. 基本情况 男，00后，大学生。记录一些学习和生活中的点滴。 2. 座右铭 在你二三十岁的时候要寻找自我，不要糟蹋它第一，不要被欲望糟蹋第二，不要被自怜糟蹋今天的世界是无数代人共同铸造的我们还要不断地塑造新的世界观保持一份清明保持良心的独立性面对滔天大浪的时候要冷静，要有信心不再追求短暂的高兴的“快”不再追求短暂的虚荣的“乐”我活到今天相当辛苦但是我不能回头我也不需要回头我一路辛苦过来保持了自己的存在从来没想过糟蹋自己也没有屈服于这个世界你要理解，你是完整的人这一辈子“完整的人”这四个字是你的责任保持你的完整不屈服、不腐化、不猥琐你是顶天立地的人世界因你的存在而改变因你的不在而缺憾许倬云"}],"posts":[{"title":"Proxifier:应用级代理管理","slug":"Proxifier-应用级代理管理","date":"2023-03-24T08:46:39.000Z","updated":"2023-03-24T09:42:32.523Z","comments":true,"path":"2023/03/24/Proxifier-应用级代理管理/","link":"","permalink":"https://zhangdoudou.github.io/2023/03/24/Proxifier-%E5%BA%94%E7%94%A8%E7%BA%A7%E4%BB%A3%E7%90%86%E7%AE%A1%E7%90%86/","excerpt":"Proxifier是一款功能非常强大的代理客户端，可以实现代理部分应用程序上网。","text":"Proxifier是一款功能非常强大的代理客户端，可以实现代理部分应用程序上网。 1. 需求描述在学习过程中，科学上网是一个不得不会的事，比如访问github，google等网站，大多数vpn软件和windows系统的代理设置只提供全局或者局部代理模式，代理规则并不清楚，也不太容易控制。我理想中比较喜欢的方式是：vpn软件开一个代理端口，浏览器或者应用程序可以控制是否使用代理，这样就能做到不需要用代理的就不用。 2. 浏览器的解决办法：SwitchyOmega扩展SwitchyOmega是一个chrome浏览器扩展，可以实现根据不同网站的域名决定是否使用代理。SwitchyOmega可以帮助用户非常方便地浏览国外网站，能够自动帮你把设置好的代理进行合适的切换，基本上已经解决自主可控代理的大部分问题了，毕竟大部分科学上网的需求是在浏览网页中产生的。（详细使用教程：代理拓展程序-SwitchyOmega） 3. 应用程序的解决办法：Proxifier直到我开始使用一款文献管理与阅读软件zotero，这款软件通过访问诸如谷歌翻译等接口提供内置的pdf翻译功能，这个软件很好用，但是访问谷歌翻译需要科学上网，zotero作为一个应用程序，如何实现控制其使用特定代理访问外部网络是我一直想解决的问题。当然，这个问题肯定是可以解决的，实现上不是很难，对于我而言最好的解决办法就是能找到一个应用级代理管理软件。我断断续续百度了几次，终于我发现了Proxifier。Proxifier是一款功能非常强大的socks5客户端，可以实现在不同的操作系统下配合此客户端实现全局或指定程序的代理ip功能，能有效的解决单一程序的频繁设置，支持Windows XP/Vista/Win7/Win10 和 MacOS，支持http/https、socks4/5、TCP、UDP等协议，可以指定端口，指定IP，指定域名、指定程序、指定用户名密码授权等运行模式，兼容性非常好。下载链接：Proxifier中文版(代理客户端) v4.0.1 中文汉化版使用教程：如何实现Proxifier只代理部分程序上面这个教程比较详细，不再赘述，另外记录一个在使用的时候遇到的问题，配置好代理服务器和代理规则后，使用要走代理的应用访问时，发现一直报错“connection attempt failed with error 10061”，在网上没搜到比较靠谱的办法（ 請問 ~Proxifier error 10061~ 問題这个中国台湾省的帖子问题和我一样，提到说是防火墙的问题，但不太靠谱），后来尝试性把本地代理服务器的ip从localhost改为127.0.0.1就很意外的解决了，具体原因不清楚。 参考资料 代理拓展程序-SwitchyOmega 如何实现Proxifier只代理部分程序","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://zhangdoudou.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"科学上网","slug":"科学上网","permalink":"https://zhangdoudou.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}]},{"title":"二分","slug":"二分","date":"2022-10-11T03:29:18.000Z","updated":"2023-03-03T16:49:36.589Z","comments":true,"path":"2022/10/11/二分/","link":"","permalink":"https://zhangdoudou.github.io/2022/10/11/%E4%BA%8C%E5%88%86/","excerpt":"不同于有序数组的简单二分查找，789. 数的范围在更新区间时包含mid，需要考虑边界问题。","text":"不同于有序数组的简单二分查找，789. 数的范围在更新区间时包含mid，需要考虑边界问题。 1. 题目描述给定一个按照升序排列的长度为n的整数数组a，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 2. 解题思想解题思想比较直接，就是分别找到第一个不小于k的元素和最后一个不大于k的元素位置。 3. 二分查找查找的过程可以使用二分的思想，注意这里与简单的二分查找不同，被称为二分答案。在二分查找中，充分利用a[mid]与k的大小关系，当a[mid] &lt; k时，就到右区间[mid + 1, r]继续查找k；当a[mid] &gt; k时，就到左区间[l, mid - 1]继续查找k；当a[mid] == k或者查找区间长度为0时，查找结束。在二分查找的过程中下一次查找的区间是不包括上一次查找区间的mid的，这种情况下不需要考虑边界问题。 4. 二分答案在数据范围这道题目中，大小为k的元素有多个，更新区间时包含需要包含mid。下面具体看一下二分答案的两个模板。模板1123456while (l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1;&#125;模板2123456while (l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1;&#125;前人已经总结出的规律是： 第一个模板是尽量往左找目标，第二个模板是尽量往右找目标。只要是往左找答案，就用第一个模板，mid不用加一，r=mid，l加一；只要是往右找答案，就用第二个模板，mid要加一，l=mid，r要减一； 5. 边界问题二分答案的区间更新根据往左还是往右找目标进行设置，另外还有一个不同点就是mid是不是要加1，而加1与否的区别体现在：往右查找的目标元素在区间右边界的前一个（也就是倒数第二个）和往左查找的目标元素在区间左边界的后一个（也就是正数第二个），在这两种情况下，找到最后的时候，如果mid设置不对，区间长度一直为1，区间保持不变，会陷入死循环。下面是往右找目标元素3时，mid加1与不加1的过程演示。记住往右找加1，往左找不加1，区间更新做题的时候是能很快想出来的。另外也有人针对如何在最后跳出长度为1的区间死循环，更改循环条件为l+1 != r，也是一种思路，记住一种模板即可。123456789int L=-1,R=n;while(L+1!=R)&#123; int mid=L+R&gt;&gt;1; if(check()) L=mid; else R=mid; //最后根据你所分左右两边区间的结果 //选取L或者R作为结果&#125; 参考资料 二分查找 &amp; 二分答案 万字详解，超多例题，带你学透二分。 不需要考虑mid+1、mid-1的二分查找模板，希望大家都能学会","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://zhangdoudou.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"算法","slug":"算法","permalink":"https://zhangdoudou.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"整数二分","slug":"整数二分","permalink":"https://zhangdoudou.github.io/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"}]},{"title":"最长上升子序列","slug":"最长上升子序列","date":"2022-09-19T03:24:12.000Z","updated":"2023-03-03T16:49:36.589Z","comments":true,"path":"2022/09/19/最长上升子序列/","link":"","permalink":"https://zhangdoudou.github.io/2022/09/19/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"最长上升子序列是使用动态规划求解的经典题目。B3637 最长上升子序列","text":"最长上升子序列是使用动态规划求解的经典题目。B3637 最长上升子序列 1. 题目描述给定一个长度为N的数列(w[N])，求数值严格单调递增的子序列的长度最长是多少。 2. 动态规划使用动态规划的核心是构造状态转移表达式，先来看看这道题目是如何定义状态及转移方程的。定义f[i]表示以w[i]结尾的最大上升序列长度，则在w[i] &gt; w[j]时，f[i] = max(f[i], f[j] + 1)，j=0,1,2,…,i-1。上面这种情况的时候要更新状态是不难理解的，但是这也导致f[i]是由小于i的最优解通过增加w[i]产生的，有没有可能f[i]是由小于i的非最优解产生的呢，也就是说在w[i] &lt;= w[j]时，f[j]也存在信息，可以用于产生最优解，其实仔细想一下这种情况就是去除w[j]后的上升子序列加上w[i]构成的，那么一定会存在一个对应于w[i] &gt; w[q]，并使用f[i] = max(f[i], f[q] + 1)进行更新，所以在w[i] &lt;= w[j]时是不用再进行更新的。下面看一下代码。123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;int w[5010]; //输入序列int f[5010]; //状态记录int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; n; for(int i; i &lt; n; i ++) &#123; cin &gt;&gt; w[i]; &#125; int mx = 1; for(int i = 1; i &lt; n; i ++) &#123; f[i] = 1; for(int j = 0; j &lt; i; j ++) &#123; if(w[i] &gt; w[j]) &#123; f[i] = max(f[i], f[j] + 1); &#125; &#125; mx = max(mx, f[i]); &#125; cout &lt;&lt; mx; return 0;&#125;动态规划的代码总是很简洁明了，但是想出来思路就很难，特别是第一次遇到某个题目。 3. 输出一个最长上升子序列根据f[n]状态记录数组的定义，可以从小到大依次输出状态记录分别为mx,mx-1,…,1。最长上升子序列显然是可能不唯一的，下面的代码只输出一个。1234567891011121314151617181920212223int mx = 1, pos = 0;for(int i = 0; i &lt; n; i ++) &#123; if(mx &lt;= f[i]) &#123; mx = f[i]; pos = i; &#125;&#125;// 输出一个最长上升子序列int *num = new int(mx);num[0] = w[pos];int cnt = 0;for(int i = pos - 1; i &gt;= 0; i --) &#123; if(f[i] == mx - 1) &#123; num[++ cnt] = w[i]; mx --; &#125;&#125;for(int i = cnt; i &gt;= 0; i --) &#123; if(i &lt; cnt) &#123; cout &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; num[i];&#125; 参考资料 最长上升子序列(序列长度+序列输出)","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://zhangdoudou.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"算法","slug":"算法","permalink":"https://zhangdoudou.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zhangdoudou.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"素数的判定：筛法","slug":"素数的判定：筛法","date":"2022-09-17T08:36:57.000Z","updated":"2023-03-03T16:49:36.604Z","comments":true,"path":"2022/09/17/素数的判定：筛法/","link":"","permalink":"https://zhangdoudou.github.io/2022/09/17/%E7%B4%A0%E6%95%B0%E7%9A%84%E5%88%A4%E5%AE%9A%EF%BC%9A%E7%AD%9B%E6%B3%95/","excerpt":"素数很有用，特别是在密码学领域中，比如RSA中很重要的一步就是寻找两个比较大的素数，通常的做法是先随机生成一个大整数，然后使用一些素性判定的方法，比如费马素性测试。在算法竞赛的数论题目中，素数也很常见，通常的做法是先找出一定范围内的所有素数，用到时再查表，筛法就可以做到。","text":"素数很有用，特别是在密码学领域中，比如RSA中很重要的一步就是寻找两个比较大的素数，通常的做法是先随机生成一个大整数，然后使用一些素性判定的方法，比如费马素性测试。在算法竞赛的数论题目中，素数也很常见，通常的做法是先找出一定范围内的所有素数，用到时再查表，筛法就可以做到。 1. 埃氏筛埃拉托斯特尼筛法，简称埃氏筛。埃氏筛的原理是直观的，基于这样一个事实：素数不能被任意比它小的、除1以外的数整除；合数一定存在一个比它小且不为1的数整除。从2开始，当能确定一个数是质数时，就可以把这个数的整数倍标记为合数。从小到大遍历到一个数，如果它依然没有被标记为合数，那么就能确定它是质数。筛法中用到的数只有质数，筛选的对象是合数。这样做可以减少操作次数，并且可以筛掉所有的合数。123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;bool isPrime[100000010];//isPrime[i] == 1表示i是素数int Prime[60000010], cnt;//Prime存质数int n, q, k;void GetPrime(int n) &#123; memset(isPrime, true, sizeof(isPrime)); isPrime[1] = false; isPrime[2] = true; for(int i = 2; i &lt;= n; i ++) &#123; if(isPrime[i]) &#123; Prime[cnt ++] = i; for(int j = 2; i * j &lt;= n; j ++) &#123; isPrime[i * j] = false; &#125; &#125; &#125;&#125; 2. 欧拉筛埃氏筛存在重复筛的情况，欧拉筛可以保证范围内的每个合数都被筛掉，并且任一合数只被最小质因数筛掉，也就是只被筛一次。欧拉筛的时间复杂度为O(n)，因此也被成为线性筛。先来看一下代码。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;bool isPrime[100000010];//isPrime[i] == 1表示i是素数int Prime[60000010], cnt;//Prime存质数int n, q, k;void GetPrime(int n) &#123; memset(isPrime, true, sizeof(isPrime)); isPrime[1] = false; isPrime[2] = true; for(int i = 2; i &lt;= n; i ++) &#123; if(isPrime[i]) &#123; Prime[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt &amp;&amp; i * Prime[j] &lt;= n; j ++) &#123; isPrime[i * j] = false; if(i % Prime[j] == 0) &#123; break; //保证只被“最小质因数 × 最大因数（非自己） = 这个合数”筛掉 &#125; &#125; &#125;&#125;线性筛的代码和埃氏筛很相似，比较明显的不同有两处，埃氏筛中的i一定是质数，而线性筛的i是小于等于n的所有数，Prime[j]一定是质数；另一个不同就是线性筛的条件判定提前结束内层循环。我们知道欧拉筛的线性时间复杂度是因为合数只被筛一次，也就是“最小质因数 × 最大因数（非自己） = 这个合数”，条件判定提前结束就保证了这件事。举一个例子，使用埃氏筛，30会被2(*15)、3(*10)和5(*6)筛三次，在线性筛中i依次遍历到2，3，5的时候是不可能筛掉30的，因为i只和小于自己的质数相乘，i遍历到6时，因为6能整除2，所以只会筛掉12，而不会筛掉和3、5相乘得到的18、30，这是因为对于30而言可以分解为6*5，而6可以整除2的话，那么必然可以将2分给5得到一个更大的数，也就是10，所以要结束。 参考资料 埃氏筛、欧拉筛详解","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://zhangdoudou.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"算法","slug":"算法","permalink":"https://zhangdoudou.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://zhangdoudou.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"学习：复现Word2vec模型Skip-Gram的过程记录","slug":"复现Word2vec模型SkipGram","date":"2022-08-23T11:57:14.000Z","updated":"2023-03-03T16:49:36.604Z","comments":true,"path":"2022/08/23/复现Word2vec模型SkipGram/","link":"","permalink":"https://zhangdoudou.github.io/2022/08/23/%E5%A4%8D%E7%8E%B0Word2vec%E6%A8%A1%E5%9E%8BSkipGram/","excerpt":"本文word2vec原理参考：NLP扎实基础1：Word2vec模型Skip-Gram Pytorch复现","text":"本文word2vec原理参考：NLP扎实基础1：Word2vec模型Skip-Gram Pytorch复现 1. Skip-Gram与CBOW的区别CBOW（Continuous Bag-of-Words）和 Skip-Gram（Continuous Skip-gram Model）是Mikolov设计的两种用于计算连续的、分布式的词向量的模型，作者用一副非常概括、简洁的示意图来表明这两种模型的区别，这也是该论文中唯一的图。 这幅图很有对称的美，但是也很有迷惑性，在没有深入理解代码前，是很难想到作者真正实现的方法与思想。CBOW模型输入是滑动窗口内背景词的平均，输出是中心词是词典中某个词的对数softmax。Skip-Gram模型的输入相对而言就比较复杂，分别是中心词，背景词以及随机采样得到的噪声词，而后两者也被称为正例和负例，输出则是中心词与负例词向量的内积减去与正例词的内积，这也就是优化的目标。 2. 词向量表示的目标我们都知道分布式词向量的提出是神经概率语言模型的副产物，后者致力于对一个句子的概率做出预测，在该论文《A Neural Probabilistic Language Model》中举了两个例子: The cat is walking in the bedroom A dog was running in a room 第一个句子是在语料库中的，那么神经概率语言模型应该会得到一个比较大的概率值，同时第二个句子中的词都是与第一个句子中的词一一对应并且语义上相似的，也应该有一个较大的概率，然后在论文中写到“In the proposed model, it will so generalize because “similar” words should have a similar feature vector”，也就是说语义相似的词应该要有相近的特征向量表示，这样上面两个句子才能有相近的概率。 3. 殊途同归，尝试解释Skip-Gram与CBOW模型继承了这样的目标，但是实现的方法却不一样。Mikolov提出了这两种模型，并设计了测试的方法，但是论文中并没有提到设计的动机，对这两种模型进行解释有一些讨论。 首先是CBOW模型，模型的输入是背景词的平均，有一部分人是这样解释的：“句子中挨得越近的词越相似，离的越远的词越不同”，这似乎是对平均操作的分析结果。这样的想法首先违背了一般的常识，一个句子中的各个单词有不同的作用，词性也基本都不同，而且语义相似的词在一个句子里重复出现也显得累赘。《NLP扎实基础1：Word2vec模型Skip-Gram Pytorch复现》举了一组例子：“我/爱/跑步”，“我/爱/撸串”，“我/爱/烤串”，并说明虽然“我”和“爱”、“撸串”没有明显联系，但是这三个句子里“撸串”、“烤串”、“跑步”就有一定的关联，当采用CBOW或Skip-Gram训练时，这三个词会越来越近。当语料足够大的时候，“撸串”和“烤串”同时出现在类似的句子中的概率是非常大的，但是“跑步”出现的句子场景就不同了，因此就把“撸串”、“烤串”越训练越接近，而“跑步”就稍稍疏远。这个说明与神经概率语言模型中的例子有相似的思想。但是结合《NLP扎实基础2：Word2vec模型CBOW Pytorch复现》具体实现的代码就会发现存在一些问题，如果我们认为相似的词出现在相似的语境，词与词的差别会体现在语境里（这里的语境特指滑动窗口内的背景词），那么对于两个非常相似的词而言，他们有非常一致的语境，但是在词典中的位置确不一样，由于word2vec模型输出的是对数softmax，这时即使语境是相似的，模型输出也是相似的，但是和实际中心词还是会存在较大差距。 对于Skip-Gram模型来说，优化的目标是：中心词与背景词的内积要小，与噪声词的内积要大，乍一看似乎是因为“句子中挨得越近的词越相似，离的越远的词越不同”，但我认为其实是","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://zhangdoudou.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"NLP","slug":"NLP","permalink":"https://zhangdoudou.github.io/tags/NLP/"},{"name":"深度学习","slug":"深度学习","permalink":"https://zhangdoudou.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"未完成","slug":"未完成","permalink":"https://zhangdoudou.github.io/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"}]},{"title":"学习：复现Word2vec模型CBOW的过程记录","slug":"复现Word2vec模型CBOW","date":"2022-08-21T13:30:48.000Z","updated":"2023-03-03T16:49:36.589Z","comments":true,"path":"2022/08/21/复现Word2vec模型CBOW/","link":"","permalink":"https://zhangdoudou.github.io/2022/08/21/%E5%A4%8D%E7%8E%B0Word2vec%E6%A8%A1%E5%9E%8BCBOW/","excerpt":"本文word2vec原理参考：NLP扎实基础2：Word2vec模型CBOW Pytorch复现","text":"本文word2vec原理参考：NLP扎实基础2：Word2vec模型CBOW Pytorch复现 看过之后，基本上是能够理解的，在自己的电脑上运行时，对一些地方有困惑，经过查阅相关资料后才搞懂，另外，原博客中的代码还有一些bug一并解决。 1. CBOW是如何实现的 结合上述原理图，可以知道CBOW训练的主要思路是用背景词预测中心词。在没有看代码之前，对于损失计算，我的想法是：使用背景词的预测结果与当前中心词的词嵌入向量计算损失。实际上训练词嵌入的网络的最后一层的形状是（隐藏层个数，单词表个数），所以在最后一层前应该要做softmax，这种做法应该是更合适的，使用当前中心词的词嵌入向量是一种以当前最优值替代理想最优的想法，应该也能行得通，不过可能训练的时间要更久（没有实验验证）。 2. 交叉熵损失在看到使用交叉熵损失代码的时候，一看到会觉得不太对劲，损失计算的前后两个对象并不一致，这个就属于代码经验不足了。 一个运行错误12# loss = criterion(model_out, center_token)loss = criterion(model_out, center_token.long()) 原代码是python2版本的，直接运行会报错误“RuntimeError: expected scalar type Long but found Int”，修改一下即可。","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"https://zhangdoudou.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"NLP","slug":"NLP","permalink":"https://zhangdoudou.github.io/tags/NLP/"},{"name":"深度学习","slug":"深度学习","permalink":"https://zhangdoudou.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hexo：Hello World！","slug":"hello-world","date":"2022-03-07T13:13:27.163Z","updated":"2023-03-03T16:49:36.589Z","comments":true,"path":"2022/03/07/hello-world/","link":"","permalink":"https://zhangdoudou.github.io/2022/03/07/hello-world/","excerpt":"欢迎 Hexo! 这是我的第一篇博客. 访问 documentation 获取更多官方信息.本文主要记录一些常用发博客的操作以及遇到的问题。","text":"欢迎 Hexo! 这是我的第一篇博客. 访问 documentation 获取更多官方信息.本文主要记录一些常用发博客的操作以及遇到的问题。 一、快速开始1. 发布一篇新博客1$ hexo new &quot;My New Post&quot; 更多信息: Writing 2. 运行服务器1$ hexo server 更多信息: Server 3. 生成静态文件1$ hexo generate 更多信息: Generating 4. 部署到远程网站1$ hexo deploy 更多信息: Deployment 5. 上传图片图床使用github + picgo + vscode。从剪贴板处上传图片: Ctrl + Alt + U从文件管理器上传图片: Ctrl + Alt + E 6. 文章评论使用Gitment支持评论管理， gitment是imsun利用github上的issues做的评论系统，注册简单，实现方便，还没有广告。 二、遇到的问题1. 博客根目录与主题目录下_config.yml文件不一致博客根目录与主题目录下都有_config.yml文件，如果发生冲突的话后者的优先级较高，可以在后者配置局部的、与某一主题强相关的配置，而在前者配置所有主题都适用的全局配置。有很多东西已经配置并且部署后没有显示，可能是因为没有在主题目录下进行配置。 2. “所有文章”模块缺失添加“所有文章”功能的流程主要参考hexo博客添加本地搜索功能。 3. yilia主题作者名字不显示解决 hexo yilia主题作者名字不显示问题 参考资料 GitHub+Hexo 搭建个人网站详细教程 使用GitHub搭建个人免费快速的图床 使用vscode开始Markdown写作之旅 Hexo博客yilia主题添加Gitment评论系统","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"https://zhangdoudou.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"https://zhangdoudou.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://zhangdoudou.github.io/tags/yilia/"}]}],"categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://zhangdoudou.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"科学上网","slug":"科学上网","permalink":"https://zhangdoudou.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"记录","slug":"记录","permalink":"https://zhangdoudou.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"算法","slug":"算法","permalink":"https://zhangdoudou.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"整数二分","slug":"整数二分","permalink":"https://zhangdoudou.github.io/tags/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zhangdoudou.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"数学","permalink":"https://zhangdoudou.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"NLP","slug":"NLP","permalink":"https://zhangdoudou.github.io/tags/NLP/"},{"name":"深度学习","slug":"深度学习","permalink":"https://zhangdoudou.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"未完成","slug":"未完成","permalink":"https://zhangdoudou.github.io/tags/%E6%9C%AA%E5%AE%8C%E6%88%90/"},{"name":"博客","slug":"博客","permalink":"https://zhangdoudou.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"https://zhangdoudou.github.io/tags/hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://zhangdoudou.github.io/tags/yilia/"}]}